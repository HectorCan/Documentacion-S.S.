<!DOCTYPE html>
<html>
<head>
<title>index.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="how-to-solve---hash-tables">How to Solve - Hash Tables</h1>
<h2 id="mission-10---digging-into-hash-tables">Mission 10 - Digging into Hash Tables</h2>
<p>As always, this guide will help you to accomplish this mission.</p>
<p>The hash table belongs to the category of dictionaries that are data structures and algorithms that allow searching, inserting and discarding elements.</p>
<p>This is how a Hash table looks like:</p>
<p><img src="file:///home/habcb/Uni/S.S.-Docs/T_10-Hash_Tables/img/T-Hash_1.png" alt="Simple Linked List"></p>
<p>But how it works?.</p>
<p>When we use a hash table, we assign a specific memory space to store information, we use a Hash function which consists of getting the best value to store it.</p>
<h3 id="scout-boy---exploration">Scout Boy - Exploration</h3>
<p>What is a Hash Table? Well we can explain in more detail with the following image:</p>
<p><img src="file:///home/habcb/Uni/S.S.-Docs/T_10-Hash_Tables/img/hash-intro.png" alt="Hash Table Introduction"></p>
<p>You can see that with a <strong>key</strong> we compute it with a <strong>Hash Function</strong> so we can obtain a <strong>index</strong>, and our data will be stored in that <strong>index</strong>.</p>
<p>With this Structure of Data we can do searchs with cost O(1)</p>
<p>Well, let's explain furthermore, we can tell that we have a <strong>Hash Function</strong> (The Hash Function is a function that computes the key to obtain the index).
For this example we can say that our Hash Function is the following:</p>
<p><strong>The sum of the values in ascii</strong> modulo <strong>The Size of the Hash Table</strong></p>
<p>The key Maria could be in the position 5.
But, also the key airaM, note that is Maria the other way around.</p>
<p>In these cases we can have something called a <strong>collision</strong>, there are many few methods to avoid this:</p>
<ol>
<li>If the index is occuped, search the next index available.</li>
<li>Change the Hash Function to avoid that Maria y airaM get the same index.</li>
<li>Use an Array to Store the data.</li>
</ol>
<p>But, there is always a but...</p>
<ol>
<li>
<p>For the first case imagine that our index is 0, 0 is occupied and we have 999 spaces, and only the index 998 is available. We need to iterate from 0 to 998 to check that the space is available. Our search method cost will become O(N). So this is not a correct solution.</p>
</li>
<li>
<p>For the second case indeed Maria and airaM will have different index, but we can have the key Jorge to have the same index that airaM, so this doesn't solve the problem in this case.</p>
</li>
<li>
<p>For the third case, we would only iterate in the same space when a collision occurs.</p>
</li>
</ol>
<p>So you can see there is not much option to avoid collision, yes with better methods we can have less collissions, but there will be a way to get the collision.</p>
<p>Tablas Abiertas - Listas Simples - Dinamico
Cerradas - Array Estatico</p>
<p>And that's all for an explanation for Hash Tables, that can be resumed in the following image:</p>
<p><img src="file:///home/habcb/Uni/S.S.-Docs/T_10-Hash_Tables/img/hash-resume.png" alt="Hash Resume"></p>
<p>0 y 1 no son guarda elementos Jorge</p>
<p><strong>NOTE</strong>: Don't forget the image only explains what usually does the Hash table, not how to prevent collision.</p>
<h2 id="objectives">Objectives</h2>
<h3 id="objective-1-remember">Objective 1. Remember</h3>
<p>We are going to return to a previous lesson, simple linked list. For the moment we need a simple linked list that accomplishes the following structure:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Jameson"</span>
}
</div></code></pre>
<p>This is going to be the structure that we will be using as our data, for that we need to create the correct structure:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// Structure Person</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> {</span>
  <span class="hljs-built_in">string</span> name;
} Person;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  Person p;
  p.name = <span class="hljs-string">"Oscar"</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="objective-2-initialize-the-hash-table">Objective 2. Initialize the Hash Table</h3>
<p>With this, you can see the Person structure as the Point Structure used in the previous lessons. Now you must work on the Simple Linked List. For the moment just keep the Initialization of the Simple Linked List and the Insertion. (If you are having doubt if using a queue or a stack, don't worry use any of them).</p>
<p>We will use the name List to refer to the Simple Linked List.</p>
<p>As you must remember from the Scout Exploration, a hash table seems like a dictionary and each index has it's own simple linked list. To have a more understandable example we will create a Hash Table that uses all the characters in the alphabet.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// .. List functions and declarations</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">//...</span>
  List hashTable[<span class="hljs-number">26</span>]; <span class="hljs-comment">// ñ is not included</span>

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>With only this line we have an array (or list) of the datatype List (Simple Linked List), maybe you are thinking that we are only having one item, but remember, the Simple Linked List Nodes refers to another node using pointers, so the thing that we are achieving is a matrix where the number of columns can be different in each row.</p>
<p><img src="file:///home/habcb/Uni/S.S.-Docs/T_10-Hash_Tables/img/matrix-cols.png" alt="Hash Table"></p>
<p>With this you have mainly everything. Now we will be explaining a little further another topics.</p>
<p>And yes, of course you need to iterato over each element in <strong>hashTable</strong> to initialize the simple linked list centinel. You have already the code to initialize the Simple Linked List so we can continue with the following objective.</p>
<h3 id="objective-3-hash-function">Objective 3. Hash Function</h3>
<p>We have explained what the <strong>Hash function</strong> is. Is a function that receives a key and evaluates which will be the correct index for that key.</p>
<p>For a simple hash function we can retrieve the first character of the key and use it as the index:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashFunction</span><span class="hljs-params">(<span class="hljs-built_in">string</span> key)</span>
</span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">toupper</span>(key[<span class="hljs-number">0</span>]) - <span class="hljs-number">65</span>) % <span class="hljs-number">26</span>;
}
</div></code></pre>
<p>with this we can have the index based on the first character of the key. This hash function must not be used, since it has an error with the ñ, but since is for explanation on this tutorial we will be using it.</p>
<p>For insertion use the push function of the Simple Linked List.</p>
<h3 id="objective-4-search">Objective 4. Search</h3>
<p>This is an easy job, since you already have the index where the data is stored. The only thing left is search the element in the simple linked list.</p>
<p>But is as easy as:</p>
<pre class="hljs"><code><div><span class="hljs-function">Person <span class="hljs-title">search</span><span class="hljs-params">(List *head, <span class="hljs-keyword">bool</span> *<span class="hljs-built_in">isValid</span>, <span class="hljs-built_in">string</span> key)</span>
</span>{
  List *iterator = head-&gt;next; <span class="hljs-comment">// The first element is the centinel</span>
  Person elem;

  <span class="hljs-comment">// Iterate until you reach the end</span>
  <span class="hljs-comment">// and the person name is not equal to the key</span>
  <span class="hljs-keyword">while</span> (iterator-&gt;next != iterator &amp;&amp; key != iterator-&gt;person.name) {
    iterator = iterator-&gt;next;
  }

  <span class="hljs-comment">// Check if is a valid person</span>
  *<span class="hljs-built_in">isValid</span> = iterator != head;
  elem = iterator-&gt;person;

  <span class="hljs-keyword">return</span> elem;
}
</div></code></pre>
<p>As you can see is very easy to do in a simple linked list.</p>
<p>And as easy as that is the hash table, the only complex in this program is that you create a correct hash function. But the actions required for this program are in majority provided by the Simple Linked List.</p>

</body>
</html>
